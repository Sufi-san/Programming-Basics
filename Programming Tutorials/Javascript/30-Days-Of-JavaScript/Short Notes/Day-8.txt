Variable Scopes:
- Global (Anything declared without let, var or const in the main function, is at Global level)
- Local (Access only in certain parts of the code, can be 'Block Scope' or 'Function Scope')

'var', 'let' & 'const':
- 'let' and 'const' variables have 'Block Scope', they cannot be accessed out of the block they were declared in.
- 'var' has a 'Function Scope'. This means that they can be accessed anywhere in the function they were declared in irrespective of the block they were declared in.
- Note: 'var' variables can also be accessed before their declaration takes place in the function given that it actually does take place in the same function body. The initial value of that variable at that point will be 'undefined' as no values were assigned. This is also called 'variable hoisting'. 
- The recommended way to declare variables however for ES6+ is 'let' and 'const' to avoid the sneakiness of 'var' variables.

Objects:
- Key-value pairs where order of the keys is not reserved.
- To create objects we use '{}' curly brackets.
- Properties can by anything: string, number, boolean, another object, null, undefined, function.
- Object values can be accessed and assigned to, either by using the 'object.key'(dot) operator or square brackets (["key-name"]). Square brackets are mostly used for those keys that have spaces in their names.

- for referring to the object inside that object itself, we use the 'this' keyword.
- When a property of the object is a 'function' and we need to use the 'this' keyword inside the function to refer to the object, we should NOT use an 'arrow' function.
Q. Why to use regular functions and NOT the 'arrow' function?
A: 
    In regular functions, the value of 'this' is determined at runtime based on how the function is called. It can refer to the global object (in strict mode, it's undefined), the object it's a method of, or the object passed as the first argument to call, apply, or bind.
    Arrow functions, on the other hand, capture the 'this' value from the enclosing scope at the time of their definition. This behavior is often referred to as lexical 'this'
Eg1: 
    const obj1 = {
        name: "User",
        displayName: function() {
            console.log(this.name); // (this == obj1)
        },
        displayNameArr: () => {
            console.log(this.name); // (this == window OR the 'this' from the enclosing scope)
        }
    }
    obj1.displayName(); // User
    obj1.displayNameArr(); // ""
-- In above example, 'this' in the arrow function is NOT 'obj1' reference but rather the reference for 'this' that 'obj1' itself has. Here, 'obj1' is the enclosing scope for the arrow function.

Eg2:
    const obj2 = {
        name: "User",
        displayName: function() {
            console.log(this.name);
            (() => {console.log(this.name)})(); (this == obj1)
        }
    }
    obj2.displayName();
    // User
    // User 
-- In above example, 'this' in the arrow function is 'obj2' reference because the 'displayName()' function is the enclosing scope and the 'this' reference for the enclosing scope is 'obj2'.

- Objects, like Arrays, are non-primitive and mutable.

Useful Object class methods:
- Object.assign(target Object, source Object) -> copies all key-value pairs from source and adds them to target
- Object.keys() -> Get the keys(properties) of an object in array form
- Object.values() -> Get the values (literals) of an object in array form
- Object.entries() -> An array of arrays where every internal array's first element indicates the key and the second one indicates the said key's value.

The .hasOwnProperty(key name) for every 'individual object': to check whether the object has a certain property
We can also use the class Method Object.hasOwn(object-name, key) for the same.
Both return a boolean value, 'true' if object has the property and 'false' otherwise.
